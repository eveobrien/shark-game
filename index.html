<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flappy Shark</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      background: #1a1429;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      border: 4px solid #6f4fa3;
      image-rendering: pixelated;
      cursor: pointer;
    }
  </style>
</head>
<body>

<canvas id="game" width="800" height="1000"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

const DEV_MODE = true;


// === COLORS ===
const COLORS = {
  purpleMain: "#9b7bd3",
  purpleDark: "#6f4fa3",
  redCoral: "#7a2b3a",
  redCoralDark: "#5b1e2d",
  yellowSoft: "#f2d16b",
  yellowGold: "#d6b85a",
  bg: "#1a1429",
  pinkSparkle: "#ff4fd8",
  pinkSparkleLight: "#ff8fe7",
  blueShark: "#8fd3ff",
  white: "#ffffff",

};

// === GAME STATE ===
let gameState = "start";      // start | playing | gameover | freeze | transition | valentine | accepted
let frame = 0;
let score = 0;

// Transition/freeze
let freezeTimer = 0;
let transitionOffset = 0;
let fadeAlpha = 0;

// Sparkles
let sparkles = [];
let vHearts = [];
let vStars = [];
let vSharks = [];



// === PHYSICS ===
const gravity = 0.5;
const jumpStrength = -7;
const pipeGap = 110;
const pipeWidth = 40;
const pipeSpeed = 2;

// === SHARK ===
const shark = {
  x: 90,
  y: canvas.height / 2,
  size: 16,
  velocity: 0
};

let pipes = [];

// === BACKGROUND ===
let stars = [];
let bubbles = [];

// === GHOST + SECRET ===
let currentRunPath = [];
let ghostPath = JSON.parse(localStorage.getItem("ghostPath")) || [];
let bestScore = Number(localStorage.getItem("bestScore")) || 0;
let secretUnlocked = localStorage.getItem("secretUnlocked") === "true";
let showSecretMessage = false;

// === INIT BACKGROUND ===
for (let i = 0; i < 80; i++) {
  stars.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    speed: Math.random() * 0.25 + 0.1
  });
}
for (let i = 0; i < 30; i++) {
  bubbles.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    size: Math.random() * 3 + 2,
    speed: Math.random() * 0.35 + 0.2
  });
}

// === INPUT ===
document.addEventListener("keydown", e => {
  if (e.code !== "Space") return;

  if (gameState === "start") resetGame();
  else if (gameState === "playing") shark.velocity = jumpStrength;
  else if (gameState === "gameover") gameState = "start";
});


document.addEventListener("keydown", (e) => {
  if (!DEV_MODE) return;

  // Press V to instantly test the full sequence
  if (e.code === "KeyV") {
    showSecretMessage = true;
    gameState = "freeze";
    freezeTimer = 0;
    transitionOffset = 0;
    fadeAlpha = 0;
  }

  // Press B to jump straight to the Valentine screen
  if (e.code === "KeyB") {
    gameState = "valentine";
    initValentineParticles();
  }
});


// === VALENTINE BUTTONS (centered) ===
function getValentineButtons() {
  const cx = canvas.width / 2;
  const y = Math.round(canvas.height * 0.55);
  const w = 140;
  const h = 50;
  const gap = 30;

  const left = { x: Math.round(cx - gap/2 - w), y, w, h };
  const right = { x: Math.round(cx + gap/2), y, w, h };
  return { left, right };
}

canvas.addEventListener("click", (e) => {
  if (gameState !== "valentine") return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const { left, right } = getValentineButtons();
  const inRect = (r) => x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h;

  if (inRect(left) || inRect(right)) {
    spawnSparkles(canvas.width / 2, Math.round(canvas.height * 0.46));
    gameState = "accepted";
  }
});

// === RESET ===
function resetGame() {
  shark.y = canvas.height / 2;
  shark.velocity = 0;
  pipes = [];
  score = 0;
  frame = 0;
  currentRunPath = [];
  showSecretMessage = false;

  // reset transition variables for a fresh run
  freezeTimer = 0;
  transitionOffset = 0;
  fadeAlpha = 0;
  sparkles = [];

  gameState = "playing";
}

// === CORAL CREATION ===
function createPipe() {
  const topHeight = Math.floor(Math.random() * (canvas.height - pipeGap - 140) + 70);
  pipes.push({
    x: canvas.width,
    top: topHeight,
    bottom: topHeight + pipeGap,
    swaySeed: Math.random() * Math.PI * 2,
    polyps: Array.from({ length: 10 }, () => Math.random()),
    scored: false
  });
}

// === UPDATE ===
function update() {
  frame++;
  updateBackground();

  if (gameState === "playing") {
    shark.velocity += gravity;
    shark.y += shark.velocity;
    currentRunPath.push({ y: shark.y });

    if (frame % 120 === 0) createPipe();

    pipes.forEach(pipe => {
      pipe.x -= pipeSpeed;

      if (!pipe.scored && pipe.x + pipeWidth < shark.x) {
        score++;
        pipe.scored = true;
      }

      if (
        shark.x + shark.size > pipe.x &&
        shark.x < pipe.x + pipeWidth &&
        (shark.y < pipe.top || shark.y + shark.size > pipe.bottom)
      ) endGame();
    });

    pipes = pipes.filter(p => p.x + pipeWidth > 0);

    if (shark.y < 0 || shark.y + shark.size > canvas.height) endGame();
  }

  // Freeze -> Transition -> Valentine (timing lives here, not in draw)
  if (gameState === "freeze") {
    freezeTimer++;
    if (freezeTimer > 180) { // ~3 seconds
      gameState = "transition";
    }
  }

if (gameState === "transition") {
  transitionOffset += 8;
  fadeAlpha = Math.min(1, fadeAlpha + 0.02);
  if (fadeAlpha >= 1) {
    gameState = "valentine";
    initValentineParticles();
  }
}

  // === UPDATE SPARKLES ===
  sparkles.forEach(s => {
    s.x += s.vx;
    s.y += s.vy;
    s.life--;
  });
  sparkles = sparkles.filter(s => s.life > 0);
}

// === END GAME ===
function endGame() {
  const hadGhost = ghostPath.length > 0;

  // âœ… DEV MODE: always trigger the cinematic when you crash (for testing)
  if (DEV_MODE) {
    showSecretMessage = true;       // show the secret lines during freeze
    gameState = "freeze";
    freezeTimer = 0;
    transitionOffset = 0;
    fadeAlpha = 0;
    return;
  }

  // Normal behavior (ship mode)
  if (score > bestScore) {
    bestScore = score;
    ghostPath = currentRunPath;
    localStorage.setItem("bestScore", bestScore);
    localStorage.setItem("ghostPath", JSON.stringify(ghostPath));

    // Trigger only once: first time she beats an existing ghost
    if (hadGhost && !secretUnlocked) {
      secretUnlocked = true;
      showSecretMessage = true;
      localStorage.setItem("secretUnlocked", "true");

      gameState = "freeze";
      freezeTimer = 0;
      transitionOffset = 0;
      fadeAlpha = 0;
      return;
    }
  }

  gameState = "gameover";
}


// === BACKGROUND ===
function updateBackground() {
  stars.forEach(s => {
    s.y += s.speed;
    if (s.y > canvas.height) s.y = 0;
  });

  bubbles.forEach(b => {
    b.y -= b.speed;
    if (b.y < 0) b.y = canvas.height;
  });
}

function drawBackground() {
  const cycle = Math.sin(frame * 0.002) * 0.5 + 0.5;
  ctx.fillStyle = `rgb(${Math.floor(32 + cycle*25)},${Math.floor(24 + cycle*20)},${Math.floor(60 + cycle*45)})`;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Stars
  ctx.fillStyle = COLORS.yellowSoft;
  stars.forEach(s => ctx.fillRect(s.x, s.y, 2, 2));

  // Bubbles
  ctx.fillStyle = "rgba(200,210,255,0.5)";
  bubbles.forEach(b => ctx.fillRect(b.x, b.y, b.size, b.size));
}

// === SHARK ===
function drawPixelShark(x, y, a = 1) {
  ctx.save();
  ctx.globalAlpha = a;

  // pixel "glow" shadow
  ctx.fillStyle = COLORS.purpleDark;
  ctx.fillRect(x - 1, y + 1, 18, 10);

  // body
  ctx.fillStyle = COLORS.purpleMain;
  ctx.fillRect(x, y, 16, 8);
  ctx.fillRect(x + 2, y - 4, 12, 4);

  // fin + tail
  ctx.fillStyle = COLORS.purpleDark;
  ctx.fillRect(x + 6, y - 8, 4, 4);
  ctx.fillRect(x - 4, y + 2, 4, 4);

  // eye
  ctx.fillStyle = "#000";
  ctx.fillRect(x + 12, y + 2, 2, 2);

  ctx.restore();
}

// === CORAL DRAWING ===
function drawCoral(pipe, y, height, flip = 1) {
  const sway = Math.sin(frame * 0.02 + pipe.swaySeed) * 3;
  const x = pipe.x + sway * flip;

  ctx.fillStyle = COLORS.redCoral;
  ctx.fillRect(x, y, pipeWidth, height);

  // bumps
  for (let i = 0; i < height; i += 16) {
    ctx.fillRect(x - 4, y + i, 4, 10);
    ctx.fillRect(x + pipeWidth, y + i + 6, 4, 10);
  }

  // shadow
  ctx.fillStyle = COLORS.redCoralDark;
  ctx.fillRect(x + pipeWidth - 4, y, 4, height);

  // tiny yellow polyps (sparkle)
  ctx.fillStyle = COLORS.yellowSoft;
  pipe.polyps.forEach((p, i) => {
    if (Math.sin(frame * 0.05 + p * 10) > 0.6) {
      const px = x + (i * 7) % (pipeWidth - 2);
      const py = y + (i * 29) % Math.max(1, height - 2);
      ctx.fillRect(px, py, 2, 2);
    }
  });
}

// === GHOST ===
function drawGhost() {
  if (gameState === "playing" && ghostPath.length > frame) {
    drawPixelShark(shark.x, ghostPath[frame].y, 0.22);
  }
}

// === DRAW PIPES ===
function drawPipes() {
  pipes.forEach(p => {
    drawCoral(p, 0, p.top, 1);
    drawCoral(p, p.bottom, canvas.height - p.bottom, -1);
  });
}

// === TEXT ===
function drawText() {
  ctx.textAlign = "center";

  if (gameState === "start") {
    ctx.font = "20px 'Press Start 2P'";
    ctx.fillStyle = COLORS.purpleMain;
    ctx.fillText("FLAPPY SHARK", canvas.width / 2, 220);

    ctx.font = "12px 'Press Start 2P'";
    ctx.fillStyle = COLORS.yellowSoft;
    ctx.fillText("IT REMEMBERS YOU", canvas.width / 2, 300);
    ctx.fillText("PRESS SPACE", canvas.width / 2, 340);
  }

  if (gameState === "playing") {
    ctx.font = "18px 'Press Start 2P'";
    ctx.fillStyle = COLORS.yellowGold;
    ctx.fillText(score, canvas.width / 2, 70);
  }

  if (gameState === "gameover") {
    ctx.font = "18px 'Press Start 2P'";
    ctx.fillStyle = COLORS.purpleMain;
    ctx.fillText("AGAIN?", canvas.width / 2, canvas.height / 2);
    ctx.font = "12px 'Press Start 2P'";
    ctx.fillStyle = COLORS.yellowSoft;
    ctx.fillText("PRESS SPACE", canvas.width / 2, canvas.height / 2 + 40);
  }

  // Secret message appears on gameover when it unlocks (it will quickly freeze after)
  if (gameState === "freeze") {
    ctx.font = "12px 'Press Start 2P'";
    ctx.fillStyle = "#fff";
    ctx.fillText("IF YOU CAN OUTSWIM", canvas.width / 2, 260);
    ctx.fillText("YOUR PAST,", canvas.width / 2, 290);

    ctx.fillStyle = COLORS.yellowSoft;
    ctx.fillText("IMAGINE WHAT WE", canvas.width / 2, 330);

    ctx.fillStyle = "#fff";
    ctx.fillText("CAN BUILD TOGETHER", canvas.width / 2, 360);
  }
}

// === SPARKLES ===
function spawnSparkles(x, y) {
  for (let i = 0; i < 24; i++) {
    sparkles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.7) * 6,
      life: 40
    });
  }
}

function drawSparkles(color = COLORS.yellowSoft) {
  ctx.fillStyle = color;
  sparkles.forEach(s => ctx.fillRect(s.x, s.y, 2, 2));
}


// === VALENTINE SCREEN ===
function drawHeart(cx, cy) {
  const pulse = Math.sin(frame * 0.08) * 2; // small pulse
  const s = 10 + pulse;

  ctx.fillStyle = COLORS.yellowSoft;
  // simple pixel heart
  ctx.fillRect(cx - s - 2, cy, s, s);
  ctx.fillRect(cx + 2, cy, s, s);
  ctx.fillRect(cx - s, cy + s - 2, s * 2 + 4, s);
  ctx.fillRect(cx - (s - 2), cy + (s * 2) - 4, (s * 2) - 4, s);
}


function updateValentineParticles() {
  // hearts float upward + sway
  vHearts.forEach(h => {
    h.y -= h.speed;
    h.x += Math.sin(frame * h.tw + h.phase) * 0.6 + h.drift;

    if (h.y < -40) {
      h.y = canvas.height + 40 + Math.random() * 200;
      h.x = Math.random() * canvas.width;
    }
  });

  // sharks swim across + bob
  vSharks.forEach(s => {
    s.x += s.speed * s.dir;
    s.bob += 0.03;

    if (s.dir === 1 && s.x > canvas.width + 60) {
      s.x = -60 - Math.random() * 200;
      s.y = 160 + Math.random() * (canvas.height - 260);
    }
    if (s.dir === -1 && s.x < -60) {
      s.x = canvas.width + 60 + Math.random() * 200;
      s.y = 160 + Math.random() * (canvas.height - 260);
    }
  });
}

function drawTinyHeart(x, y, size, color) {
  ctx.fillStyle = color;
  const s = Math.max(4, size);

  // 2 top pixels + one body
  ctx.fillRect(x, y, s, s);
  ctx.fillRect(x + s + 2, y, s, s);
  ctx.fillRect(x + 2, y + s, (s * 2), s);
  ctx.fillRect(x + 4, y + (s * 2), (s * 2) - 4, s);
}

function drawTinyShark(x, y, dir) {
  ctx.save();
  ctx.translate(x, y);
  if (dir === -1) {
    ctx.scale(-1, 1);
  }

  // white highlight
  ctx.fillStyle = COLORS.white;
  ctx.fillRect(2, 2, 14, 6);

  // blue body
  ctx.fillStyle = COLORS.blueShark;
  ctx.fillRect(0, 4, 16, 6);
  ctx.fillRect(4, 0, 10, 4);

  // fin
  ctx.fillStyle = COLORS.white;
  ctx.fillRect(8, -4, 4, 4);

  // tail
  ctx.fillStyle = COLORS.blueShark;
  ctx.fillRect(-4, 6, 4, 4);

  // eye
  ctx.fillStyle = "#000";
  ctx.fillRect(12, 6, 2, 2);

  ctx.restore();
}

function drawValentineTwinkles() {
  // stars
  vStars.forEach(st => {
    const on = Math.sin(frame * st.tw + st.x * 0.01) > 0.6;
    if (on) {
      ctx.fillStyle = COLORS.yellowSoft;
      ctx.fillRect(st.x, st.y, 2, 2);
      ctx.fillRect(st.x - 2, st.y, 2, 2);
      ctx.fillRect(st.x + 2, st.y, 2, 2);
      ctx.fillRect(st.x, st.y - 2, 2, 2);
      ctx.fillRect(st.x, st.y + 2, 2, 2);
    }
  });

  // pink sparkle dust
  if (frame % 2 === 0) {
    for (let i = 0; i < 6; i++) {
      sparkles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.2,
        vy: (Math.random() - 0.5) * 0.2,
        life: 18
      });
    }
  }
}



function drawValentineScreen() {
  // Update particles (only while on this screen)
  updateValentineParticles();

  // Background
  ctx.fillStyle = COLORS.bg;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Twinkles / stars / sparkle dust
  drawValentineTwinkles();

  // Floating hearts
  vHearts.forEach(h => {
    const pulse = Math.sin(frame * h.tw + h.phase) > 0.4;
    drawTinyHeart(h.x, h.y, h.size, pulse ? COLORS.yellowSoft : COLORS.yellowGold);
  });

  // Tiny sharks swimming (cute + subtle)
  vSharks.forEach(s => {
    const bobY = Math.sin(s.bob) * 4;
    drawTinyShark(s.x, s.y + bobY, s.dir);
  });

  // Main text
  const cx = canvas.width / 2;

  ctx.textAlign = "center";
  ctx.font = "22px 'Press Start 2P'";
  ctx.fillStyle = COLORS.purpleMain;
  ctx.fillText("CATHERINE,", cx, 280);

  ctx.fillStyle = COLORS.yellowSoft;
  ctx.fillText("WILL YOU BE MY", cx, 330);

  ctx.fillStyle = COLORS.pinkSparkle;
  ctx.fillText("VALENTINE?", cx, 380);

  // Buttons centered
  const { left, right } = getValentineButtons();

  ctx.fillStyle = COLORS.purpleMain;
  ctx.fillRect(left.x, left.y, left.w, left.h);
  ctx.fillRect(right.x, right.y, right.w, right.h);

  ctx.fillStyle = "#fff";
  ctx.font = "16px 'Press Start 2P'";
  ctx.fillText("YES", left.x + left.w / 2, left.y + 34);
  ctx.fillText("YES", right.x + right.w / 2, right.y + 34);

  // Sparkles on top (pink!)
  drawSparkles(COLORS.pinkSparkleLight);
}




function initValentineParticles() {
  vHearts = [];
  vStars = [];
  vSharks = [];

  // Floating hearts
  for (let i = 0; i < 28; i++) {
    vHearts.push({
      x: Math.random() * canvas.width,
      y: canvas.height + Math.random() * canvas.height,
      speed: 0.6 + Math.random() * 0.8,
      drift: (Math.random() - 0.5) * 0.6,
      phase: Math.random() * Math.PI * 2,
      size: 6 + Math.floor(Math.random() * 6),
      tw: Math.random() * 0.08 + 0.03
    });
  }

  // Twinkly stars
  for (let i = 0; i < 60; i++) {
    vStars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      tw: Math.random() * 0.12 + 0.03
    });
  }

  // Tiny swimming sharks
  for (let i = 0; i < 7; i++) {
    const dir = Math.random() < 0.5 ? -1 : 1;
    vSharks.push({
      dir,
      x: dir === 1 ? -40 - Math.random() * 200 : canvas.width + 40 + Math.random() * 200,
      y: 160 + Math.random() * (canvas.height - 260),
      speed: 0.8 + Math.random() * 1.2,
      bob: Math.random() * Math.PI * 2
    });
  }
}






// === MAIN DRAW ===
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // World (optionally sliding up during transition)
  ctx.save();
  if (gameState === "transition") ctx.translate(0, -transitionOffset);

  drawBackground();
  drawPipes();
  drawGhost();
  drawPixelShark(shark.x, shark.y);
  drawText();

  ctx.restore();

  // Fade overlay during transition
  if (gameState === "transition") {
    ctx.fillStyle = `rgba(26,20,41,${fadeAlpha})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // Valentine / Accepted screens
  if (gameState === "valentine") {
    drawValentineScreen();
  }

  if (gameState === "accepted") {
  ctx.fillStyle = COLORS.bg;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // keep some cute motion
  updateValentineParticles();
  drawValentineTwinkles();
  vHearts.forEach(h => drawTinyHeart(h.x, h.y, h.size, COLORS.yellowSoft));
  vSharks.forEach(s => drawTinyShark(s.x, s.y + Math.sin(s.bob) * 4, s.dir));

  ctx.textAlign = "center";
  ctx.fillStyle = COLORS.pinkSparkle;
  ctx.font = "26px 'Press Start 2P'";
  ctx.fillText("YAYYYYY ðŸ’–", canvas.width / 2, canvas.height / 2 - 30);

  ctx.fillStyle = COLORS.yellowSoft;
  ctx.font = "18px 'Press Start 2P'";
  ctx.fillText("I'M YOURS.", canvas.width / 2, canvas.height / 2 + 20);

  drawSparkles(COLORS.pinkSparkleLight);
}
}
// === LOOP ===
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
